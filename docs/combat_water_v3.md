Architectural Specification for High-Fidelity Hydrodynamic Simulation in Bevy: A Quadtree-Accelerated Approach for Sailing Mechanics1. IntroductionThe simulation of fluid dynamics in real-time applications represents one of the most persistent challenges in computational physics. In the context of a sailing game, the fluid medium is not merely a passive backdrop but the primary antagonist and protagonist of the gameplay experience. The interactions between the vessel and the water—buoyancy, drag, wave propagation, and displacement—must be modeled with a degree of physical fidelity that allows for emergent behavior, yet must be computationally efficient enough to run at interactive frame rates alongside complex game logic.This report articulates a comprehensive architectural framework for implementing a two-dimensional, shallow-water fluid simulation using a Linear Quadtree data structure within the Bevy game engine. The proposed system is designed to satisfy stringent requirements: bidirectional coupling between rigid bodies (ships) and the fluid, support for arbitrary polygonal hitboxes, and a decoupling of simulation frequency from rendering frame rate to ensure deterministic physics. Furthermore, the rendering pipeline is designed to achieve a stylized, vector-based aesthetic, distinct from the photorealistic approaches common in the industry.The analysis draws upon advanced concepts in Computational Fluid Dynamics (CFD), specifically the Virtual Pipe Method (VPM) and Finite Volume Methods (FVM), adapted for adaptive mesh refinement (AMR). It leverages Rust’s memory safety and Bevy’s Entity Component System (ECS) to build a highly parallelized, data-oriented simulation.1.1 Scope and ObjectivesThe primary technical objectives addressed in this document include:Adaptive Resolution: Utilizing a quadtree data structure to concentrate computational resources in regions of high hydrodynamic interest (e.g., near the ship hull or coastlines) while coarsening the grid in open water.Two-Way Coupling: Implementing a physics solver where ships displace water mass (creating bow waves and wakes) and water exerts buoyant and drag forces on the ship, calculated via precise polygon clipping rather than simplified bounding volumes.Data-Oriented Architecture: Structuring the simulation using Morton Codes (Z-order curves) to implement a Linear Quadtree, optimizing for CPU cache locality and avoiding the memory fragmentation inherent in pointer-based trees.Stylized Rendering: developing a custom rendering pipeline that interprets the simulation state to generate a vector-art aesthetic, utilizing GPU instancing for performance.2. Mathematical Foundations of Interactive Fluid DynamicsTo achieve the "push and be pushed" mechanic requested, purely kinematic approaches (such as summing sine waves) are insufficient. Kinematic waves do not conserve mass; pushing them down at one point does not cause them to rise elsewhere. Consequently, a dynamic solver based on the conservation laws of physics is required.2.1 The Shallow Water Equations (SWE)For a sailing game, we can assume the horizontal length scale of the flow is significantly larger than the vertical depth. This assumption allows the integration of the Navier-Stokes equations over the depth of the fluid, yielding the Shallow Water Equations. These equations describe the evolution of the water height $h(x,y,t)$ and the depth-averaged horizontal velocity $\mathbf{u} = (u,v)$.The conservative form of the 2D SWE is given by:$$\frac{\partial h}{\partial t} + \nabla \cdot (h\mathbf{u}) = S$$$$\frac{\partial (h\mathbf{u})}{\partial t} + \nabla \cdot \left( h\mathbf{u} \otimes \mathbf{u} + \frac{1}{2}gh^2 \mathbf{I} \right) = -gh\nabla b - \mathbf{\tau}$$Where:$h$ is the fluid column height.$b$ is the bathymetry (bottom topography).$g$ is the gravitational acceleration.$S$ is the source/sink term, which will be utilized to model displacement by ships.$\mathbf{\tau}$ represents bottom friction and viscous drag.The first equation represents the conservation of mass: the change in water height is driven by the divergence of the flux ($h\mathbf{u}$). If more water flows into a cell than leaves it, the level rises. The second equation represents the conservation of momentum, accounting for advection, hydrostatic pressure gradient ($\frac{1}{2}gh^2$), and external forces.12.2 The Virtual Pipe Method (VPM)While solving the full SWE is accurate, it is numerically complex to implement on a dynamic quadtree due to the Riemann problem at cell interfaces. A simplified, yet physically plausible alternative for game development is the Virtual Pipe Method. This approach discretizes the domain into a grid of vertical columns connected by virtual pipes.3In the VPM, the flow $Q_{ij}$ (flux) between cell $i$ and neighbor $j$ is driven by the hydrostatic pressure difference:$$Q_{ij}^{t+\Delta t} = Q_{ij}^t + \Delta t \cdot A_{pipe} \cdot \frac{g (h_i - h_j)}{L_{ij}}$$$$h_i^{t+\Delta t} = h_i^t + \frac{\Delta t}{A_{cell}} \sum_{j \in \text{neighbors}} Q_{ji}$$This method effectively solves a damped wave equation. It naturally handles "communicating vessels"—if a ship pushes water down in one cell, the pressure increases, driving flow to neighbors, simulating a splash or wave. It is inherently mass-conserving, which is critical for the gameplay mechanic where a heavy ship must visibly displace a corresponding volume of water.2.3 Challenges of Adaptive Mesh Refinement (AMR)Implementing these equations on a quadtree introduces a topological challenge: the T-junction or "hanging node." In a uniform grid, every cell interface connects exactly two cells of equal size. In a quadtree, a large cell (leaf at depth $D$) may neighbor two smaller cells (leaves at depth $D+1$).Flux Conservation at T-junctions:To prevent "leaking" momentum or mass, the solver must enforce flux consistency. The flux leaving the large cell $L$ across its eastern face must equal the sum of fluxes entering the smaller neighbor cells $S_1$ and $S_2$:$$\Phi_{L \to E} = \Phi_{E \to S1} + \Phi_{E \to S2}$$Standard finite difference methods fail here. We must adopt a Finite Volume Method (FVM), where updates are based on the integral of fluxes over the cell boundaries.2 This ensures that even when the grid resolution changes dynamically (e.g., as a ship moves), the total mass of the water remains constant.The following table summarizes the trade-offs between simulation methods for this specific use case:MethodConservation of MassComputational CostQuadtree AdaptabilitySuitability for Sailing GameFFT Ocean (Tessendorf)NoLow (Uniform)PoorLow (Visuals only, no interaction)SPH (Particles)YesHighN/A (Lagrangian)Medium (Good splashing, hard to stabilize ships)Lattice Boltzmann (LBM)YesVery HighMediumLow (Too expensive for large oceans)Finite Volume SWE / VPMYesMediumHighHigh (Robust coupling & waves)3. Spatial Partitioning: The Linear Quadtree ImplementationThe choice of data structure is the single most critical architectural decision for performance in Rust. Traditional object-oriented quadtrees, composed of nodes on the heap pointing to children (Box<Node>), suffer from three major defects in a high-performance context:Memory Fragmentation: Nodes are scattered in RAM, causing excessive cache misses during traversal.Borrow Checker Friction: Rust's ownership model makes doubly-linked trees (parent pointers) difficult to manage without RefCell or unsafe, adding runtime overhead or complexity.Traversal Overhead: Finding a neighbor requires traversing up to the common ancestor and back down, an $O(\log N)$ operation.To address these, we employ a Linear Quadtree using Morton Codes (Z-order curve).53.1 Morton Codes and Z-Order CurvesMorton coding maps multidimensional coordinates $(x, y)$ to a one-dimensional integer index ($z$) by interleaving the binary representations of the coordinates. This mapping preserves spatial locality: points that are close in 2D space are generally close in the linear sequence.For a coordinate $(x, y)$ represented by bits $x_1x_0$ and $y_1y_0$, the Morton code is $y_1x_1y_0x_0$.Implementation in Rust:Efficient bit-interleaving is achieved using "Magic Numbers" to spread the bits. For 16-bit coordinates (supporting a $65536 \times 65536$ grid), we expand to a 32-bit Morton code.7Rust// Spreads the lower 16 bits of x into the odd bits of a 32-bit integer
fn spread_bits_16(mut x: u16) -> u32 {
    let mut x = x as u32;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;
    x
}

pub fn morton_encode(x: u16, y: u16) -> u32 {
    spread_bits_16(x) | (spread_bits_16(y) << 1)
}
This function transforms spatial coordinates into a key that can be stored in a flat array or hash map.3.2 The OceanGrid ResourceIn Bevy, the quadtree is best represented as a global Resource. We need to store the active nodes. There is a debate between using a Vec (sorted by Morton code) or a HashMap.Sorted Vec: Extremely cache-efficient for iteration. Lookup is $O(\log N)$ via binary search. Best for static grids.HashMap: $O(1)$ average lookup. Better for dynamic grids where nodes are frequently added/removed (split/merged).Given that the grid must adapt every frame to follow the ships, a HashMap (specifically bevy::utils::HashMap which uses a fast hasher) or a SparseSet is preferred for the topological management. However, for the solver loop (which iterates sequentially), a Vec is faster. A hybrid approach is recommended: maintain the topology in a spatial hash for quick neighbor lookups during refinement, and flatten it to a Vec for the flux iteration.8Component Structure:Rust#
pub struct WaterCell {
    pub height: f32,       // h: Surface height relative to sea level
    pub velocity: Vec2,    // u: Horizontal flow velocity
    pub bottom: f32,       // b: Bathymetry (terrain height)
    pub volume: f32,       // Derived: (height - bottom) * area
}

#
pub struct OceanQuadtree {
    // Key: (Depth, MortonCode). Allows overlapping nodes during refinement transitions.
    pub nodes: HashMap<(u8, u32), WaterCell>,
    pub max_depth: u8,
    pub tile_size: f32,    // Physical size of a cell at depth 0
}
3.3 Constant-Time Neighbor FindingThe primary advantage of Morton codes in this simulation is the ability to calculate neighbor keys using bitwise arithmetic, avoiding tree traversal. To find the neighbor to the East of cell $(x, y)$, we simply compute morton_encode(x + 1, y).However, because of AMR, the neighbor might exist at a different depth. The neighbor finding algorithm is as follows 10:Algorithm: find_neighbors(cell_key, direction)Candidate 1 (Same Size): Calculate the Morton code for the neighbor at the current depth. Check if it exists in OceanQuadtree.nodes.If found: Return it.Candidate 2 (Coarser/Parent): If not found, calculating the neighbor's code effectively points to a non-existent leaf. We calculate the parent's code by shifting bits (integer division by 4).If parent exists: This is a T-junction where the current cell is small and the neighbor is large. Return the parent.Candidate 3 (Finer/Children): If neither exists, the neighbor must be split. We look for the child nodes at depth + 1 that border the shared edge.Example: If looking East, we check the North-West and South-West children of the hypothetical eastern neighbor.This capability is what makes the Finite Volume Method feasible in real-time; we can construct the flux graph dynamically without chasing pointers.4. Physics Coupling: Rigid Body InteractionThe requirement for "two-way" interaction implies a feedback loop:Ship $\rightarrow$ Water: Displacement forces water out of cells, creating waves.Water $\rightarrow$ Ship: Hydrostatic pressure (buoyancy) and hydrodynamic drag act on the ship.4.1 Accurate Buoyancy via Polygon ClippingMost game engines approximate buoyancy using a set of point probes (test points) scattered on the hull. For a sailing game, this is insufficient as it fails to accurately capture the righting moment (torque) generated by the hull shape when heeling. We require an exact calculation of the submerged volume.We treat the ship's hull as a 2D polygon (from the "vector" requirement). We treat the water surface in the local quadtree cell as a clipping plane (or line segment in 2D).The Sutherland-Hodgman Algorithm:This algorithm clips a subject polygon (the hull) against a convex clipping window (the water volume).Transform the ship's polygon vertices into world space.For each active quadtree cell intersecting the ship's AABB:Define the "water polygon" as the rectangular region of the cell up to the water height $h$.Clip the ship polygon against this water rectangle.The result is a new polygon representing the submerged section of the hull in that cell.Calculating Forces:From the submerged polygon $P_{sub}$, we calculate:Area ($A$): Represents the volume of displaced fluid (in 2D).Centroid ($C$): The geometric center of the submerged area.The buoyant force $F_b$ is:$$F_b = \rho_{water} \cdot A \cdot g \cdot \mathbf{\hat{j}}$$where $\mathbf{\hat{j}}$ is the up vector.Crucially, this force is applied at the Centroid $C$, not the ship's center of mass.If the ship is upright, $C$ and Center of Mass (CoM) align vertically.If the ship heels (tilts), $C$ shifts sideways. The misalignment between the upward buoyant force at $C$ and the downward gravity at CoM creates a torque that attempts to right the ship. This is the essence of sailing stability.124.2 Displacement: The "Plunger" EffectTo satisfy the requirement that "water is pushed by ships," we must modify the fluid state based on the ship's presence.Method 1: Direct Height Field ModificationIf the ship's hull depth at a cell is $d_{hull}$ and the water height is $h_{water}$, and $d_{hull} < h_{water}$ (the hull is deeper than the surface), the water must move.We enforce a constraint: $h_{water} = \min(h_{water}, d_{hull})$.The "missing" water mass $\Delta m = (h_{old} - h_{new}) \times A_{cell}$ is not deleted. It is added to the flux of the adjacent cells. This creates a pressure spike at the hull boundary, generating a bow wave that propagates outward.Method 2: Velocity Entrainment (Drag)The friction between the hull and water transfers momentum.$$\mathbf{u}_{water}^{new} = \mathbf{u}_{water}^{old} + \alpha C_f (\mathbf{v}_{ship} - \mathbf{u}_{water}^{old})$$This entrainment creates the wake behind the ship. Conversely, we apply an equal and opposite drag force to the ship:$$F_{drag} = -\frac{1}{2} \rho C_d A_{cross} |\mathbf{v}_{rel}| \mathbf{v}_{rel}$$where $\mathbf{v}_{rel} = \mathbf{v}_{ship} - \mathbf{u}_{water}$. This allows currents to push the ship.4.3 Integration with Bevy XPBD (Avian)The simulation uses avian2d (formerly bevy_xpbd_2d) for rigid body integration.We use the ExternalForce component to apply the calculated buoyancy and drag.Rustfn apply_buoyancy(
    mut ships: Query<(&Collider, &GlobalTransform, &mut ExternalForce)>,
    ocean: Res<OceanQuadtree>,
) {
    for (collider, transform, mut force) in ships.iter_mut() {
        let (area, centroid) = calculate_submerged_geometry(collider, transform, &ocean);
        
        if area > 0.0 {
            let buoyancy_mag = area * WATER_DENSITY * GRAVITY;
            let buoyancy_force = Vec2::Y * buoyancy_mag;
            
            // Avian applies force at a specific world point, generating torque automatically
            force.apply_force_at_point(buoyancy_force, centroid, transform.translation().xy());
        }
    }
}
5. Bevy Implementation ArchitectureBevy's ECS requires a strict separation of data (Components) and logic (Systems). To achieve "smooth" yet deterministic physics, we must decouple the simulation tick from the render frame.5.1 The FixedUpdate Loop (Simulation Layer)The fluid simulation is sensitive to time steps ($\Delta t$). If $\Delta t$ varies, the flux calculations can become unstable (violating the CFL condition). Therefore, all fluid logic resides in FixedUpdate.System Schedule:grid_adaptation_system:Query all Ship entities.Calculate their AABBs.Refine: Split quadtree nodes that intersect ship AABBs (up to MAX_DEPTH).Coarsen: Merge sibling nodes that are far from ships and have similar flow variances.Insight: Use a "hysteresis" buffer. Don't merge nodes immediately after a ship leaves; wait for waves to settle to avoid deleting wave detail.coupling_system:Calculate Submerged Polygons.Apply Displacement (modify water heights).Apply Buoyancy/Drag (queue forces for Avian).flux_calculation_system:Iterate all cells. Find neighbors.Compute virtual pipe fluxes.Optimization: Use parallel iteration (par_iter) to compute fluxes into a temporary "Flux Delta" buffer to avoid mutable aliasing.integration_system:Apply Flux Deltas to Water Heights.Apply Damping/Friction.5.2 The Update Loop (Presentation Layer)The rendering must happen every frame (e.g., 144Hz) even if physics runs at 60Hz. To prevent visual stutter, we must interpolate.Interpolation Strategy:The WaterCell struct should store height_current and height_previous.In the Update loop:$$h_{render} = \text{lerp}(h_{prev}, h_{curr}, \alpha)$$where $\alpha$ is the accumulated time fraction between fixed ticks (accessible via Time<Fixed>::overstep()).5.3 Parallelism and Rust SafetyA naive HashMap iteration prevents simultaneous mutable access to neighbors.Pattern: Double Buffering.State A (Read): Current water heights.State B (Write): New water heights.We bind State A as read-only to the Flux System. It writes fluxes to a DashMap or separate FluxMap.The Integration System reads the FluxMap and updates State B.At the end of the tick, swap A and B.This pattern maps perfectly to Bevy's system parallelism limitations and Rust's borrow checker.6. Rendering: The Stylized Vector AestheticThe request specifies a "stylized, vector" display. This suggests flat shading, clean lines, and distinct shapes, rather than noisy PBR textures.6.1 Mesh Generation vs. GPU InstancingWe have two options to render the quadtree:Dynamic Mesh: Construct a single Mesh every frame with vertices at quadtree corners.Pros: Continuous surface, easy to apply shaders.Cons: CPU heavy. Rebuilding a mesh with 50k vertices every frame is a bottleneck.GPU Instancing: Render a single "Tile" mesh (a unit quad) thousands of times.Pros: Extremely fast. We just upload a buffer of InstanceData (Position, Scale, Height).Cons: Disconnected tiles can look like "Minecraft" unless carefully handled.Recommendation: Hybrid Instancing.We use instancing for performance.13 To solve the "disconnected" look (gaps between tiles of different sizes), we use a technique called "Skirts" or geometry shaders (though WebGPU lacks geometry shaders, we can emulate this in vertex shaders).Alternatively, for the requested Vector/Stylized look, the discrete tile look might be desirable if styled correctly (e.g., like a low-poly or tactical display).6.2 The Vector Shader (WGSL)We implement a custom material in Bevy 0.15+.Vertex Shader:Receives InstanceInput containing morton_code, depth, and height.Decodes morton_code to $(x,y)$ position on the fly (or passes position directly).Scales the quad by $1.0 / 2^{depth}$.Displaces vertices vertically based on height.Fragment Shader (The "Vector" Look):To achieve the vector style:Rim Lighting: Use the Fresnel effect or depth comparison to draw a solid outline color where the water normal faces away from the camera.Foam/Shoreline Strokes:Access the Depth Buffer (available in Bevy via ViewDepthTexture).Calculate depth_diff = scene_depth - water_depth.If depth_diff < threshold, output a "Foam Color".Stylization: Instead of a smooth gradient, step the alpha to create a hard "line" of foam at the intersection of water and ship/shore.14Flat Shading: Ignore smooth normals. Calculate the face normal using dpdx and dpdy in the fragment shader and dot it with the light vector. Threshold the result (step function) to create "Cel Shaded" bands of color.6.3 Code Snippet: Custom Material (Bevy 0.15)Rust// Defining the Instance Data for the Render Pipeline
#
struct InstanceMaterialData(Vec<InstanceData>);

#
#[repr(C)]
struct InstanceData {
    position: Vec3,
    scale: f32,
    color: Vec4,
}

// In setup system
fn setup_rendering(mut commands: Commands, mut meshes: ResMut<Assets<Mesh>>) {
    // We disable frustum culling because the base mesh is at origin, 
    // but instances are spread across the world.
    commands.spawn((
        Mesh3d(meshes.add(Rectangle::default())), // The unit tile
        NoFrustumCulling, 
        InstanceMaterialData(vec!), // Populated every frame
    ));
}
7. Performance Benchmarks and OptimizationImplementing this in Rust requires awareness of specific performance pitfalls.7.1 HashMap vs. Vec StorageResearch suggests that for small collections (<20 items), a linear scan of a Vec is faster than a HashMap due to hashing overhead. However, our ocean grid will contain thousands of cells.Benchmark Insight: A flat Vec is fastest if the topology doesn't change. But our topology changes every time a ship moves (AMR).Hybrid Solution: Use a HashMap for the "active set" management. Every FixedUpdate, after refinement, flatten the HashMap into a Vec<WaterCell> and a Vec<AdjacencyIndices> for the solver loop. This "baking" step allows the solver to run over a contiguous array without hashing, maximizing SIMD usage.7.2 Range Query Optimization ("BigMin/LitMax")When finding ships in the quadtree, we shouldn't iterate all cells. We use the Morton order properties. A rectangular AABB in world space corresponds to a set of disjoint intervals on the Z-order curve.The BigMin/LitMax algorithm 6 allows us to efficiently decompose a 2D AABB into a minimal set of contiguous Morton code ranges. This allows us to query the HashMap or Vec effectively, skipping huge swathes of the ocean that are irrelevant to the ship.8. ConclusionThis report establishes a robust architectural path for a high-fidelity sailing game simulation in Bevy. By rejecting the simplified kinematic wave models in favor of a Virtual Pipe Method solver on a Linear Quadtree, we achieve physical realism—displacement, wakes, and buoyancy—that directly impacts gameplay.The use of Morton Codes addresses the performance bottlenecks of traditional quadtrees in Rust, enabling cache-friendly traversals and constant-time neighbor lookups. The integration of Polygon Clipping ensures that the "two-way" coupling is stable and produces realistic torque, essential for the "feel" of sailing. Finally, by leveraging Bevy’s Render API for instanced, custom-shaded drawing, we satisfy the aesthetic requirement for a stylized, vector display that is performant enough to handle open oceans.8.1 Actionable RecommendationsStart with the Grid: Implement the MortonCode and LinearQuadtree structs first. Verify neighbor finding with unit tests before adding physics.Debug Visualization: Use Bevy's Gizmos to draw wireframes of the quadtree cells. Visual debugging of the T-junctions is critical to solving flux leaks.Iterative Physics: Start with a simple "box" ship. Get it floating and creating waves. Then move to complex polygon hulls.Shader Prototyping: Write the "Foam" depth-check shader early. It provides immediate visual feedback on the accuracy of the ship-water intersection logic.This framework provides a professional, scalable foundation for a physics-driven marine game.9. Appendix: Core Algorithm Reference9.1 Sutherland-Hodgman Polygon Clipping (Simplified)To clip polygon $P$ against a single edge $E$ of the water volume:Input list: $V_{in}$ (vertices of $P$).Output list: $V_{out}$ (empty).Iterate through edges of $P$ (vertex $S$ to $E$).If $E$ is inside and $S$ is inside: Add $E$ to $V_{out}$.If $E$ is inside and $S$ is outside: Add Intersection($S, E$, ClipEdge) then $E$.If $E$ is outside and $S$ is inside: Add Intersection($S, E$, ClipEdge).If $E$ is outside and $S$ is outside: Do nothing.Repeat for all 4 edges of the water cell.9.2 Morton Neighbor Offsets (Bitwise)Finding neighbors without decoding:Rust// Example: Finding East neighbor (+1 x) in Z-order
// Requires dilating the integer, adding, and compacting.
// Often faster to Decode -> Add -> Encode in modern CPUs 
// unless using PDEP/PEXT instructions (AVX2).
fn neighbor_east(code: u32) -> u32 {
    let (x, y) = decode_morton(code);
    encode_morton(x + 1, y)
}
Given the complexity of bit-logic for carrying bits across the interleaved boundaries, the decode-add-encode cycle is recommended for readability and portability in Rust unless profiling shows it as a bottleneck.